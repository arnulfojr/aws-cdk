import { Construct, IResource, Lazy, Resource } from "@aws-cdk/core";
import { CfnBackupPlan } from "./backup.generated";
import { PlanRule } from "./rules";
import { BackupResource, BackupSelection } from "./selection";

/**
 * Represents a Backup Plan.
 */
export interface IBackupPlan extends IResource {
  /**
   * The backup plan's ID.
   * @attribute
   */
  readonly backupPlanId: string;
}

abstract class BackupPlanBase extends Resource implements IBackupPlan {
  public abstract readonly backupPlanId: string;
}

/**
 * Backup plan attributes.
 */
export interface BackupPlanAttributes {
  /**
   * A string representation of the backup plan name
   */
  readonly backupPlanName: string;
  /**
   * A string representation of the backup plan ARN.
   */
  readonly backupPlanArn: string;
  /**
   * A string representation of the backup plan version ID.
   */
  readonly backupPlanVersionId: string;
  /**
   * A string representation of the backup plan ID.
   */
  readonly backupPlanId: string;
}

/**
 * Properties of the Backup Plan.
 */
export interface BackupPlanProps {
  /**
   * The name of the backup plan.
   * @default - Generated by CloudFormation.
   */
  readonly backupPlanName?: string;
  /**
   * A list of plan rules to assign to the plan.
   */
  readonly rules: PlanRule[];
}

/**
 * A Backup Plan specifies where the backup resources will be stored and
 * what rules will the plan will follow.
 */
export class BackupPlan extends BackupPlanBase {
  /**
   * Imports a backup plan from its attributes.
   */
  public static fromBackupPlanAttributes(
    scope: Construct,
    id: string,
    attrs: BackupPlanAttributes
  ): IBackupPlan {
    class Import extends BackupPlanBase {
      public readonly backupPlanArn: string = attrs.backupPlanArn;
      public readonly backupPlanId: string = attrs.backupPlanId;
      public readonly backupPlanVersionId: string = attrs.backupPlanVersionId;
      public readonly backupPlanName: string = attrs.backupPlanName;
    }

    return new Import(scope, id);
  }
  /**
   * A string representatino of the backup plan ARN
   */
  public readonly backupPlanArn: string;
  /**
   * The backup plan Id.
   */
  public readonly backupPlanId: string;
  /**
   * The backup version Id.
   */
  public readonly backupPlanVersionId: string;
  /**
   * The backup plan name.
   */
  public readonly backupPlanName: string;
  /**
   * A list of rules that specify the rules of the plan.
   */
  private rules: PlanRule[];

  constructor(scope: Construct, id: string, props: BackupPlanProps) {
    super(scope, id);

    this.backupPlanName = props.backupPlanName || this.node.id;

    const resource = new CfnBackupPlan(this, "Resource", {
      backupPlan: {
        backupPlanName: this.backupPlanName,
        backupPlanRule: Lazy.anyValue({
          produce: () => this.renderPlanRules(this.rules),
        }),
      },
    });

    this.backupPlanArn = this.getResourceArnAttribute(
      resource.attrBackupPlanArn,
      {
        service: "backup",
        resource: "backup-plan",
        resourceName: resource.ref,
      }
    );
    this.backupPlanId = this.getResourceNameAttribute(resource.ref);
    this.backupPlanVersionId = resource.attrVersionId;

    this.rules = props.rules;
  }

  /**
   * Adds the given plan rules.
   */
  public addPlanRule(...rules: PlanRule[]): void {
    this.rules = [...this.rules, ...rules];
  }

  /**
   * Adds the selected resources to the backup plan.
   */
  public addSelection(name: string, ...resources: BackupResource[]) {
    new BackupSelection(this, name, {
      backupPlan: this,
      backupSelectionName: name,
      resources,
    });
  }

  private renderPlanRules(
    rules: PlanRule[]
  ): undefined | CfnBackupPlan.BackupRuleResourceTypeProperty[] {
    if (!rules) {
      return undefined;
    }

    const backupRuleResourceTypes: CfnBackupPlan.BackupRuleResourceTypeProperty[] = rules.map(
      (rule) => {
        return {
          ruleName:
            rule.ruleName || `${this.node.uniqueId}Rule${this.rules.length}`,
          targetBackupVault: rule.backupVault.backupVaultName,
          completionWindowMinutes: rule.completionWindow
            ? rule.completionWindow.toMinutes()
            : undefined,
          startWindowMinutes: rule.startWindow
            ? rule.startWindow.toMinutes()
            : undefined,
          lifecycle: this.parseRuleLifecycle(rule),
          scheduleExpression: rule.schedule.expressionString,
        };
      }
    );

    return backupRuleResourceTypes;
  }

  private parseRuleLifecycle(planRule: PlanRule) {
    if (!planRule.deleteAfter && !planRule.moveToColdStorageAfter) {
      return undefined;
    }

    const deleteAfterDays = planRule.deleteAfter
      ? planRule.deleteAfter.toDays()
      : undefined;
    const moveToColdStorageAfterDays = planRule.moveToColdStorageAfter
      ? planRule.moveToColdStorageAfter.toDays()
      : undefined;

    if (deleteAfterDays && moveToColdStorageAfterDays) {
      if (deleteAfterDays - moveToColdStorageAfterDays < 90) {
        throw new Error(
          "Deleting a backup has to be 90 days after being moved to cold storage."
        );
      }
    }

    return {
      deleteAfterDays,
      moveToColdStorageAfterDays,
    };
  }
}
